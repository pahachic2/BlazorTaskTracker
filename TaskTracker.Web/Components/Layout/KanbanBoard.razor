@using Microsoft.JSInterop
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable
@* Kanban доска компонент *@

<div class="flex gap-4 p-6 h-full">
    @foreach (var column in Columns)
    {
        <div id="column-@column.Id" class="kanban-column flex-shrink-0 w-80 bg-gray-100 rounded-lg p-4 flex flex-col group">
            <!-- Заголовок колонки -->
            <div class="flex items-center justify-between mb-4 relative @(IsColumnEditing(column.Id) ? "ring-2 ring-blue-500 rounded bg-blue-50 p-2" : "")">
                <div class="flex items-center space-x-2 flex-1">
                    @if (IsColumnEditing(column.Id))
                    {
                        <!-- Режим редактирования заголовка колонки -->
                        <div class="flex items-center space-x-2 flex-1 inline-edit-enter">
                            <input type="text" 
                                   @bind="editingColumnTitles[column.Id]" 
                                   @onkeypress="@(async (e) => await HandleColumnTitleKeyPress(e, column))"
                                   @onblur="@(async () => await SaveColumnChanges(column))"
                                   @onfocus="@((e) => SelectColumnInputText(e))"
                                   disabled="@IsColumnSaving(column.Id)"
                                   class="flex-1 px-2 py-1 text-lg font-semibold text-gray-700 bg-white border border-blue-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent @(IsColumnSaving(column.Id) ? "opacity-50 cursor-not-allowed" : "")"
                                   placeholder="Введите название колонки..."
                                   maxlength="100"
                                   @onclick:stopPropagation="true" />
                            @if (IsColumnSaving(column.Id))
                            {
                                <!-- Индикатор загрузки -->
                                <svg class="animate-spin h-5 w-5 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                            }
                            <span class="bg-gray-200 text-gray-600 px-2 py-1 rounded-full text-xs font-medium">
                                @column.Tasks.Count
                            </span>
                        </div>
                    }
                    else
                    {
                        <!-- Режим просмотра заголовка колонки -->
                        <h3 class="font-semibold text-gray-700 text-lg cursor-pointer hover:text-blue-600 transition-colors inline-editable" 
                           @onclick="@(() => StartEditingColumn(column))"
                           @onclick:stopPropagation="true"
                           title="Нажмите для редактирования названия колонки">
                            @column.Title
                        </h3>
                        <span class="bg-gray-200 text-gray-600 px-2 py-1 rounded-full text-xs font-medium">
                            @column.Tasks.Count
                        </span>
                    }
                </div>
                
                <!-- Кнопка удаления колонки (появляется при наведении) -->
                <button @onclick="@(() => HandleDeleteColumn(column))" @onclick:stopPropagation="true"
                        class="opacity-0 group-hover:opacity-100 transition-opacity bg-red-500 hover:bg-red-600 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs"
                        title="Удалить колонку">
                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                    </svg>
                </button>
            </div>

            <!-- Список задач -->
            <div class="space-y-3 flex-1 overflow-y-auto">
                @foreach (var task in column.Tasks)
                {
                    <div id="task-@task.Id" data-task-id="@task.Id" data-column-id="@column.Id"
                        class="kanban-task bg-white p-4 rounded-lg shadow-sm border border-gray-200 hover:shadow-md transition-shadow group relative @(IsTaskEditing(task.Id) ? "ring-2 ring-blue-500 bg-blue-50" : "")"
                        @onmouseenter="@(() => HandleTaskMouseEnter(task))"
                        @onclick:preventDefault="false" @onclick:stopPropagation="false">

                        <!-- Кнопка удаления (появляется при наведении) -->
                        <button @onclick="@(() => HandleDeleteTask(task))" @onclick:stopPropagation="true"
                                class="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity bg-red-500 hover:bg-red-600 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs"
                                title="Удалить задачу">
                            <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                            </svg>
                        </button>

                        <!-- Область клика для открытия задачи -->
                        <div @onclick="@(() => HandleTaskClick(task))" class="cursor-pointer">
                            <!-- Теги задачи -->
                            @if (task.Tags.Any())
                            {
                                <div class="flex flex-wrap gap-1 mb-3">
                                    @foreach (var tag in task.Tags)
                                    {
                                        <span class="@GetTagClasses(tag) px-2 py-1 rounded text-xs font-medium">
                                            @tag
                                        </span>
                                    }
                                </div>
                            }

                            <!-- Заголовок задачи -->
                            @if (IsTaskEditing(task.Id))
                            {
                                <!-- Режим редактирования заголовка -->
                                <div class="mb-2 relative inline-edit-enter">
                                    <input type="text" 
                                           @bind="editingTaskTitles[task.Id]" 
                                           @onkeypress="@(async (e) => await HandleTitleKeyPress(e, task))"
                                           @onblur="@(async () => await SaveTaskChanges(task))"
                                           @onfocus="@((e) => SelectInputText(e))"
                                           disabled="@IsTaskSaving(task.Id)"
                                           class="w-full px-2 py-1 text-sm font-medium text-gray-900 bg-white border border-blue-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent @(IsTaskSaving(task.Id) ? "opacity-50 cursor-not-allowed" : "")"
                                           placeholder="Введите название задачи..."
                                           maxlength="200"
                                           @onclick:stopPropagation="true" />
                                    @if (IsTaskSaving(task.Id))
                                    {
                                        <!-- Индикатор загрузки -->
                                        <div class="absolute right-2 top-1/2 transform -translate-y-1/2">
                                            <svg class="animate-spin h-4 w-4 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                            </svg>
                                        </div>
                                    }
                                </div>
                            }
                            else
                            {
                                <!-- Режим просмотра заголовка -->
                                <h4 class="font-medium text-gray-900 text-sm mb-2 line-clamp-2 cursor-pointer hover:text-blue-600 transition-colors inline-editable" 
                                   @onclick="@(() => StartEditingTask(task))"
                                   @onclick:stopPropagation="true"
                                   title="Нажмите для редактирования">
                                    @task.Title
                                </h4>
                            }

                            <!-- Описание задачи -->
                            @if (!string.IsNullOrEmpty(task.Description))
                            {
                                <p class="text-gray-600 text-xs mb-3 line-clamp-2">
                                    @task.Description
                                </p>
                            }

                            <!-- Нижняя часть карточки -->
                            <div class="flex items-center justify-between">
                                <!-- Дата выполнения -->
                                @if (IsTaskEditing(task.Id))
                                {
                                    <!-- Режим редактирования даты -->
                                    <div class="flex items-center space-x-1 inline-edit-enter">
                                        <svg class="w-3 h-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z">
                                            </path>
                                        </svg>
                                        <input type="date" 
                                               value="@GetEditingTaskDueDateString(task.Id)"
                                               @onchange="@((ChangeEventArgs e) => UpdateEditingTaskDueDate(task.Id, e.Value?.ToString()))"
                                               @onkeypress="@(async (e) => await HandleDateKeyPress(e, task))"
                                               @onblur="@(async () => await SaveTaskChanges(task))"
                                               disabled="@IsTaskSaving(task.Id)"
                                               class="px-1 py-0.5 text-xs border border-blue-300 rounded focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-transparent bg-white @(IsTaskSaving(task.Id) ? "opacity-50 cursor-not-allowed" : "")"
                                               @onclick:stopPropagation="true" />
                                        <button @onclick="@(async () => await ClearTaskDate(task))" 
                                                @onclick:stopPropagation="true"
                                                disabled="@IsTaskSaving(task.Id)"
                                                class="text-gray-400 hover:text-red-500 transition-colors @(IsTaskSaving(task.Id) ? "opacity-50 cursor-not-allowed" : "")"
                                                title="Очистить дату">
                                            <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                                            </svg>
                                        </button>
                                    </div>
                                }
                                else if (task.DueDate.HasValue)
                                {
                                    <!-- Режим просмотра даты -->
                                    <div class="flex items-center space-x-1 cursor-pointer hover:text-blue-600 transition-colors inline-editable"
                                         @onclick="@(() => StartEditingTask(task))"
                                         @onclick:stopPropagation="true"
                                         title="Нажмите для редактирования даты">
                                        <svg class="w-3 h-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z">
                                            </path>
                                        </svg>
                                        <span class="@GetDueDateClasses(task.DueDate.Value) text-xs">
                                            @task.DueDate.Value.ToString("dd MMM")
                                        </span>
                                    </div>
                                }
                                else
                                {
                                    <!-- Отображение когда даты нет -->
                                    <div class="flex items-center space-x-1 cursor-pointer hover:text-blue-600 transition-colors opacity-50 inline-editable"
                                         @onclick="@(() => StartEditingTask(task))"
                                         @onclick:stopPropagation="true"
                                         title="Нажмите для добавления даты">
                                        <svg class="w-3 h-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z">
                                            </path>
                                        </svg>
                                        <span class="text-xs text-gray-400">Добавить дату</span>
                                    </div>
                                }

                                <!-- Аватары исполнителей -->
                                @if (task.Assignees.Any())
                                {
                                    <div class="flex -space-x-1">
                                        @foreach (var assignee in task.Assignees.Take(3))
                                        {
                                            <div class="w-6 h-6 rounded-full @GetAssigneeColor(assignee) flex items-center justify-center border-2 border-white text-white text-xs font-medium"
                                                title="@assignee">
                                                @assignee.Substring(0, 1).ToUpper()
                                            </div>
                                        }
                                        @if (task.Assignees.Count > 3)
                                        {
                                            <div class="w-6 h-6 rounded-full bg-gray-400 flex items-center justify-center border-2 border-white text-white text-xs font-medium"
                                                title="Еще @(task.Assignees.Count - 3)">
                                                +@(task.Assignees.Count - 3)
                                            </div>
                                        }
                                    </div>
                                }
                            </div>
                        </div>
                    </div>
                }
            </div>

            <!-- Кнопка добавления задачи -->
            <button @onclick="@(() => OnAddTaskToColumn.InvokeAsync(column.Id))"
                class="mt-3 w-full py-2 border-2 border-dashed border-gray-300 rounded-lg text-gray-500 hover:border-gray-400 hover:text-gray-600 transition-colors text-sm">
                + Добавить задачу
            </button>
        </div>
    }

    <!-- Кнопка добавления новой колонки -->
    @if (ShowAddColumnButton)
    {
        <div class="flex-shrink-0 w-80">
            <button @onclick="HandleAddColumn"
                class="w-full h-32 border-2 border-dashed border-gray-300 rounded-lg text-gray-500 hover:border-gray-400 hover:text-gray-600 transition-colors flex flex-col items-center justify-center space-y-2">
                <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6">
                    </path>
                </svg>
                <span class="text-sm font-medium">Добавить колонку</span>
            </button>
        </div>
    }
</div>

@code {
    // Параметры компонента
    [Parameter] public List<KanbanColumn> Columns { get; set; } = new();
    [Parameter] public bool ShowAddColumnButton { get; set; } = true;

    // События
    [Parameter] public EventCallback<KanbanTask> OnTaskClick { get; set; }
    [Parameter] public EventCallback<string> OnAddTaskToColumn { get; set; }
    [Parameter] public EventCallback OnAddColumn { get; set; }
    [Parameter] public EventCallback<TaskMovedEventArgs> OnTaskMoved { get; set; }
    [Parameter] public EventCallback<KanbanTask> OnTaskDelete { get; set; }
[Parameter] public EventCallback<KanbanColumn> OnColumnDelete { get; set; }
[Parameter] public EventCallback<KanbanTask> OnTaskUpdate { get; set; }
[Parameter] public EventCallback<KanbanColumn> OnColumnUpdate { get; set; }

private bool jsInteropDone = false;

// Состояние для inline редактирования задач
private Dictionary<string, bool> taskEditingStates = new Dictionary<string, bool>();
private Dictionary<string, string> editingTaskTitles = new Dictionary<string, string>();
private Dictionary<string, DateTime?> editingTaskDueDates = new Dictionary<string, DateTime?>();
private Dictionary<string, bool> taskSavingStates = new Dictionary<string, bool>(); // Индикатор загрузки
private string? currentEditingTaskId = null; // Только одна задача может редактироваться одновременно

// Состояние для inline редактирования колонок
private Dictionary<string, bool> columnEditingStates = new Dictionary<string, bool>();
private Dictionary<string, string> editingColumnTitles = new Dictionary<string, string>();
private Dictionary<string, bool> columnSavingStates = new Dictionary<string, bool>(); // Индикатор загрузки
private string? currentEditingColumnId = null; // Только одна колонка может редактироваться одновременно
    private DotNetObjectReference<KanbanBoard>? dotNetRef;
    private bool isTaskMoving = false; // Флаг для предотвращения переинициализации во время перемещения

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        Console.WriteLine($"🔄 BLAZOR: OnAfterRenderAsync вызван, firstRender: {firstRender}, jsInteropDone: {jsInteropDone}");

        if (firstRender)
        {
            Console.WriteLine("🔄 BLAZOR: Это первый рендер, начинаем инициализацию...");

            dotNetRef = DotNetObjectReference.Create(this);
            Console.WriteLine("🔄 BLAZOR: DotNetObjectReference создан");

            // Проверяем базовые JavaScript функции
            try
            {
                var hasWindow = await JSRuntime.InvokeAsync<bool>("eval", "typeof window !== 'undefined'");
                Console.WriteLine($"🔄 BLAZOR: Window объект доступен: {hasWindow}");

                var hasConsole = await JSRuntime.InvokeAsync<bool>("eval", "typeof console !== 'undefined'");
                Console.WriteLine($"🔄 BLAZOR: Console объект доступен: {hasConsole}");

                // Принудительно выводим сообщение в консоль
                await JSRuntime.InvokeVoidAsync("console.log", "🔄 BLAZOR: Тест вызова JavaScript из Blazor");

                // Проверяем наш объект
                var hasKanbanDragDrop = await JSRuntime.InvokeAsync<bool>("eval", "typeof window.kanbanDragDrop !== 'undefined'");
                Console.WriteLine($"🔄 BLAZOR: kanbanDragDrop объект доступен: {hasKanbanDragDrop}");

                if (!hasKanbanDragDrop)
                {
                    Console.WriteLine("❌ BLAZOR: kanbanDragDrop не найден! Проверяем загрузку скрипта...");

                    // Попробуем загрузить скрипт принудительно
                    await JSRuntime.InvokeVoidAsync("eval", @"
if (!window.kanbanDragDrop) {
console.log('🔄 JS: Попытка принудительной загрузки kanbanDragDrop...');
var script = document.createElement('script');
script.src = 'js/kanban-drag-drop.js';
script.onload = function() { console.log('✅ JS: Скрипт загружен принудительно'); };
script.onerror = function() { console.log('❌ JS: Ошибка загрузки скрипта'); };
document.head.appendChild(script);
}
");

                    // Ждем загрузки
                    await Task.Delay(1000);

                    hasKanbanDragDrop = await JSRuntime.InvokeAsync<bool>("eval", "typeof window.kanbanDragDrop !== 'undefined'");
                    Console.WriteLine($"🔄 BLAZOR: После принудительной загрузки kanbanDragDrop доступен: {hasKanbanDragDrop}");
                }

                if (hasKanbanDragDrop)
                {
                    await InitializeDragAndDrop();
                }
                else
                {
                    Console.WriteLine("❌ BLAZOR: Не удалось загрузить kanbanDragDrop!");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"❌ BLAZOR: Ошибка при проверке JavaScript: {ex.Message}");
            }
        }
        else if (jsInteropDone && !isTaskMoving)
        {
            // Если это не первый рендер, но JS уже инициализирован,
            // переинициализируем drag-and-drop для всех задач
            Console.WriteLine("🔄 BLAZOR: Переинициализация drag-and-drop для обновленных задач...");
            await ReinitializeDragAndDrop();
        }
        else if (isTaskMoving)
        {
            Console.WriteLine("⏸️ BLAZOR: Переинициализация пропущена - задача в процессе перемещения");
        }
    }

    private async Task InitializeDragAndDrop()
    {
        try
        {
            Console.WriteLine("🚀 BLAZOR: Начинаем инициализацию drag-and-drop...");

            // Инициализируем drag-and-drop для всех задач и колонок
            foreach (var column in Columns)
            {
                Console.WriteLine($"🏗️ BLAZOR: Инициализация колонки: {column.Id} с {column.Tasks.Count} задачами");

                // Сначала инициализируем drop zone для колонки
                await JSRuntime.InvokeVoidAsync("kanbanDragDrop.initColumnDropZone", $"column-{column.Id}", column.Id, dotNetRef);

                // Затем инициализируем drag для всех задач в колонке
                foreach (var task in column.Tasks)
                {
                    Console.WriteLine($"🎯 BLAZOR: Инициализация задачи: {task.Id} ({task.Title}) в колонке {column.Id}");
                    await JSRuntime.InvokeVoidAsync("kanbanDragDrop.initTaskDragDrop", $"task-{task.Id}", task.Id, column.Id);
                }
            }

            Console.WriteLine("✅ BLAZOR: Drag-and-drop инициализирован успешно!");
            jsInteropDone = true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ BLAZOR: Ошибка инициализации drag-and-drop: {ex.Message}");
        }
    }

    private async Task ReinitializeDragAndDrop()
    {
        try
        {
            Console.WriteLine("🔄 BLAZOR: Переинициализация drag-and-drop...");

            // Небольшая задержка, чтобы DOM успел обновиться
            await Task.Delay(100);

            // Переинициализируем drag-and-drop для всех задач
            foreach (var column in Columns)
            {
                foreach (var task in column.Tasks)
                {
                    Console.WriteLine($"🔄 BLAZOR: Переинициализация задачи: {task.Id} в колонке {column.Id}");
                    await JSRuntime.InvokeVoidAsync("kanbanDragDrop.initTaskDragDrop", $"task-{task.Id}", task.Id, column.Id);
                }
            }

            Console.WriteLine("✅ BLAZOR: Переинициализация drag-and-drop завершена!");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ BLAZOR: Ошибка переинициализации drag-and-drop: {ex.Message}");
        }
    }

    private async Task HandleTaskClick(KanbanTask task)
    {
        Console.WriteLine($"🖱️ BLAZOR: Клик по задаче: {task.Title}");
        await OnTaskClick.InvokeAsync(task);
    }

    private void HandleTaskMouseEnter(KanbanTask task)
    {
        Console.WriteLine($"🐭 BLAZOR: Наведение мыши на задачу: {task.Title} (ID: {task.Id})");
    }

    private async Task HandleAddColumn()
    {
        Console.WriteLine("🔥 KANBAN: Нажата кнопка 'Добавить колонку'");
        if (OnAddColumn.HasDelegate)
        {
            await OnAddColumn.InvokeAsync();
        }
    }

    private async Task HandleDeleteTask(KanbanTask task)
    {
        Console.WriteLine($"🗑️ KANBAN: Запрос на удаление задачи: {task.Title}");
        if (OnTaskDelete.HasDelegate)
        {
            await OnTaskDelete.InvokeAsync(task);
        }
    }

    private async Task HandleDeleteColumn(KanbanColumn column)
    {
        Console.WriteLine($"🗑️ KANBAN: Запрос на удаление колонки: {column.Title}");
        if (OnColumnDelete.HasDelegate)
        {
            await OnColumnDelete.InvokeAsync(column);
        }
    }

    [JSInvokable]
    public async Task OnTaskDropped(string taskId, string fromColumnId, string toColumnId)
    {
        Console.WriteLine($"🎯 BLAZOR: Получен drop события - задача {taskId} из {fromColumnId} в {toColumnId}");

        // Устанавливаем флаг для предотвращения переинициализации
        isTaskMoving = true;

        var args = new TaskMovedEventArgs
        {
            TaskId = taskId,
            FromColumnId = fromColumnId,
            ToColumnId = toColumnId
        };

        // Вызываем родительский обработчик
        await OnTaskMoved.InvokeAsync(args);

        // Снимаем флаг через некоторое время
        _ = Task.Run(async () =>
        {
            await Task.Delay(300); // Даем время завершить операцию перемещения
            isTaskMoving = false;
            Console.WriteLine($"🎯 BLAZOR: Флаг isTaskMoving сброшен для задачи {taskId}");
        });

        Console.WriteLine($"✅ BLAZOR: Событие drop обработано и передано родителю");
    }

    // Методы для inline редактирования - проверка состояния
    private bool IsTaskEditing(string taskId)
    {
        return taskEditingStates.ContainsKey(taskId) && taskEditingStates[taskId];
    }

    private bool IsTaskSaving(string taskId)
    {
        return taskSavingStates.ContainsKey(taskId) && taskSavingStates[taskId];
    }

    // Методы для inline редактирования колонок - проверка состояния
    private bool IsColumnEditing(string columnId)
    {
        return columnEditingStates.ContainsKey(columnId) && columnEditingStates[columnId];
    }

    private bool IsColumnSaving(string columnId)
    {
        return columnSavingStates.ContainsKey(columnId) && columnSavingStates[columnId];
    }

    // Методы управления редактированием
    private void StartEditingTask(KanbanTask task)
    {
        // Отменяем редактирование другой задачи, если она есть
        if (currentEditingTaskId != null && currentEditingTaskId != task.Id)
        {
            CancelEditingTask(currentEditingTaskId);
        }

        currentEditingTaskId = task.Id;
        taskEditingStates[task.Id] = true;
        
        // Сохраняем текущие значения для редактирования
        editingTaskTitles[task.Id] = task.Title ?? "";
        editingTaskDueDates[task.Id] = task.DueDate;
        
        StateHasChanged();
        
        // Фокус на поле ввода через небольшую задержку
        _ = Task.Run(async () =>
        {
            await Task.Delay(50);
            await InvokeAsync(async () =>
            {
                try
                {
                    await JSRuntime.InvokeVoidAsync("eval", $@"
                        setTimeout(() => {{
                            const titleInput = document.querySelector('#task-{task.Id} input[type=""text""]');
                            if (titleInput) {{
                                titleInput.focus();
                                titleInput.select();
                            }}
                        }}, 10);
                    ");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"❌ Ошибка фокуса на input: {ex.Message}");
                }
            });
        });
    }

    private void CancelEditingTask(string taskId)
    {
        var task = GetTaskById(taskId);
        if (task == null) return;
        
        // Восстанавливаем исходные значения
        if (editingTaskTitles.ContainsKey(taskId))
        {
            editingTaskTitles[taskId] = task.Title;
        }
        
        if (editingTaskDueDates.ContainsKey(taskId))
        {
            editingTaskDueDates[taskId] = task.DueDate;
        }
        
        // Выходим из режима редактирования
        if (taskEditingStates.ContainsKey(taskId))
        {
            taskEditingStates[taskId] = false;
        }
        
        if (currentEditingTaskId == taskId)
        {
            currentEditingTaskId = null;
        }
        
        StateHasChanged();
    }

    private async Task SaveTaskChanges(KanbanTask task)
    {
        // Предотвращаем множественные сохранения
        if (IsTaskSaving(task.Id))
        {
            Console.WriteLine($"⏳ Задача {task.Id} уже сохраняется, пропускаем...");
            return;
        }

        var hasChanges = false;
        var validationErrors = new List<string>();
        
        // Проверяем и валидируем изменения в названии
        if (editingTaskTitles.ContainsKey(task.Id))
        {
            var newTitle = editingTaskTitles[task.Id]?.Trim();
            
            // Валидация заголовка
            if (string.IsNullOrEmpty(newTitle))
            {
                validationErrors.Add("Название задачи не может быть пустым");
            }
            else if (newTitle.Length > 200)
            {
                validationErrors.Add("Название задачи не может быть длиннее 200 символов");
            }
            else if (newTitle != task.Title)
            {
                task.Title = newTitle;
                hasChanges = true;
            }
        }
        
        // Проверяем и валидируем изменения в дате
        if (editingTaskDueDates.ContainsKey(task.Id))
        {
            var newDueDate = editingTaskDueDates[task.Id];
            
            // Валидация даты
            if (newDueDate.HasValue && newDueDate.Value.Date < DateTime.Today)
            {
                validationErrors.Add("Дата выполнения не может быть в прошлом");
            }
            else if (newDueDate != task.DueDate)
            {
                task.DueDate = newDueDate;
                hasChanges = true;
            }
        }

        // Если есть ошибки валидации, показываем их и не сохраняем
        if (validationErrors.Any())
        {
            await JSRuntime.InvokeVoidAsync("alert", $"Ошибки валидации:\n{string.Join("\n", validationErrors)}");
            return; // Не выходим из режима редактирования
        }

        // Сохраняем изменения через родительский компонент
        if (hasChanges && OnTaskUpdate.HasDelegate)
        {
            Console.WriteLine($"💾 Сохраняем изменения для задачи {task.Id}...");
            
            // Устанавливаем состояние загрузки
            taskSavingStates[task.Id] = true;
            StateHasChanged();
            
            try
            {
                await OnTaskUpdate.InvokeAsync(task);
                Console.WriteLine($"✅ Задача {task.Id} успешно сохранена");
                
                // Показываем индикатор успеха
                await ShowSuccessAnimation(task.Id);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"❌ Ошибка сохранения задачи {task.Id}: {ex.Message}");
                // Возвращаем оригинальные значения при ошибке
                var originalTask = GetTaskById(task.Id);
                if (originalTask != null)
                {
                    editingTaskTitles[task.Id] = originalTask.Title;
                    editingTaskDueDates[task.Id] = originalTask.DueDate;
                }
            }
            finally
            {
                // Снимаем состояние загрузки
                taskSavingStates[task.Id] = false;
            }
        }
        
        // Выходим из режима редактирования
        CancelEditingTask(task.Id);
    }

    private KanbanTask? GetTaskById(string taskId)
    {
        foreach (var column in Columns)
        {
            var task = column.Tasks.FirstOrDefault(t => t.Id == taskId);
            if (task != null) return task;
        }
        return null;
    }

    // Методы управления редактированием колонок
    private void StartEditingColumn(KanbanColumn column)
    {
        // Отменяем редактирование другой колонки, если она есть
        if (currentEditingColumnId != null && currentEditingColumnId != column.Id)
        {
            CancelEditingColumn(currentEditingColumnId);
        }

        // Отменяем редактирование задач при начале редактирования колонки
        if (currentEditingTaskId != null)
        {
            CancelEditingTask(currentEditingTaskId);
        }

        currentEditingColumnId = column.Id;
        columnEditingStates[column.Id] = true;
        
        // Сохраняем текущее значение для редактирования
        editingColumnTitles[column.Id] = column.Title ?? "";
        
        StateHasChanged();
        
        // Фокус на поле ввода через небольшую задержку
        _ = Task.Run(async () =>
        {
            await Task.Delay(50);
            await InvokeAsync(async () =>
            {
                try
                {
                    await JSRuntime.InvokeVoidAsync("eval", $@"
                        setTimeout(() => {{
                            const titleInput = document.querySelector('#column-{column.Id} input[type=""text""]');
                            if (titleInput) {{
                                titleInput.focus();
                                titleInput.select();
                            }}
                        }}, 10);
                    ");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"❌ Ошибка фокуса на input колонки: {ex.Message}");
                }
            });
        });
    }

    private void CancelEditingColumn(string columnId)
    {
        var column = GetColumnById(columnId);
        if (column == null) return;
        
        // Восстанавливаем исходное значение
        if (editingColumnTitles.ContainsKey(columnId))
        {
            editingColumnTitles[columnId] = column.Title;
        }
        
        // Выходим из режима редактирования
        if (columnEditingStates.ContainsKey(columnId))
        {
            columnEditingStates[columnId] = false;
        }
        
        if (currentEditingColumnId == columnId)
        {
            currentEditingColumnId = null;
        }
        
        StateHasChanged();
    }

    private async Task SaveColumnChanges(KanbanColumn column)
    {
        // Предотвращаем множественные сохранения
        if (IsColumnSaving(column.Id))
        {
            Console.WriteLine($"⏳ Колонка {column.Id} уже сохраняется, пропускаем...");
            return;
        }

        var hasChanges = false;
        var validationErrors = new List<string>();
        
        // Проверяем и валидируем изменения в названии
        if (editingColumnTitles.ContainsKey(column.Id))
        {
            var newTitle = editingColumnTitles[column.Id]?.Trim();
            
            // Валидация заголовка
            if (string.IsNullOrEmpty(newTitle))
            {
                validationErrors.Add("Название колонки не может быть пустым");
            }
            else if (newTitle.Length > 100)
            {
                validationErrors.Add("Название колонки не может быть длиннее 100 символов");
            }
            else if (newTitle != column.Title)
            {
                // Проверка уникальности названия колонки в рамках проекта
                var duplicateColumn = Columns.FirstOrDefault(c => c.Id != column.Id && 
                    string.Equals(c.Title?.Trim(), newTitle, StringComparison.OrdinalIgnoreCase));
                
                if (duplicateColumn != null)
                {
                    validationErrors.Add("Колонка с таким названием уже существует");
                }
                else
                {
                    column.Title = newTitle;
                    hasChanges = true;
                }
            }
        }

        // Если есть ошибки валидации, показываем их и не сохраняем
        if (validationErrors.Any())
        {
            await JSRuntime.InvokeVoidAsync("alert", $"Ошибки валидации:\n{string.Join("\n", validationErrors)}");
            return; // Не выходим из режима редактирования
        }

        // Сохраняем изменения через родительский компонент
        if (hasChanges && OnColumnUpdate.HasDelegate)
        {
            Console.WriteLine($"💾 Сохраняем изменения для колонки {column.Id}...");
            
            // Устанавливаем состояние загрузки
            columnSavingStates[column.Id] = true;
            StateHasChanged();
            
            try
            {
                await OnColumnUpdate.InvokeAsync(column);
                Console.WriteLine($"✅ Колонка {column.Id} успешно сохранена");
                
                // Показываем индикатор успеха
                await ShowColumnSuccessAnimation(column.Id);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"❌ Ошибка сохранения колонки {column.Id}: {ex.Message}");
                // Возвращаем оригинальное значение при ошибке
                var originalColumn = GetColumnById(column.Id);
                if (originalColumn != null)
                {
                    editingColumnTitles[column.Id] = originalColumn.Title;
                }
            }
            finally
            {
                // Снимаем состояние загрузки
                columnSavingStates[column.Id] = false;
            }
        }
        
        // Выходим из режима редактирования
        CancelEditingColumn(column.Id);
    }

    private KanbanColumn? GetColumnById(string columnId)
    {
        return Columns.FirstOrDefault(c => c.Id == columnId);
    }

    // Обработчики событий для inline редактирования
    private async Task HandleTitleKeyPress(KeyboardEventArgs e, KanbanTask task)
    {
        if (e.Key == "Enter")
        {
            await SaveTaskChanges(task);
        }
        else if (e.Key == "Escape")
        {
            CancelEditingTask(task.Id);
        }
    }

    private async Task SelectInputText(FocusEventArgs e)
    {
        // Выделяем весь текст при фокусе на input
        await JSRuntime.InvokeVoidAsync("eval", "event.target.select()");
    }

    private async Task HandleDateKeyPress(KeyboardEventArgs e, KanbanTask task)
    {
        if (e.Key == "Enter")
        {
            await SaveTaskChanges(task);
        }
        else if (e.Key == "Escape")
        {
            CancelEditingTask(task.Id);
        }
    }

    private async Task ClearTaskDate(KanbanTask task)
    {
        // Предотвращаем действие если уже сохраняется
        if (IsTaskSaving(task.Id))
        {
            return;
        }
        
        editingTaskDueDates[task.Id] = null;
        await SaveTaskChanges(task);
    }

    private string GetEditingTaskDueDateString(string taskId)
    {
        if (editingTaskDueDates.ContainsKey(taskId) && editingTaskDueDates[taskId].HasValue)
        {
            return editingTaskDueDates[taskId]!.Value.ToString("yyyy-MM-dd");
        }
        return "";
    }

    private void UpdateEditingTaskDueDate(string taskId, string? dateString)
    {
        if (string.IsNullOrEmpty(dateString))
        {
            editingTaskDueDates[taskId] = null;
        }
        else if (DateTime.TryParse(dateString, out DateTime parsedDate))
        {
            editingTaskDueDates[taskId] = parsedDate;
        }

        StateHasChanged();
    }

    // Обработчики событий для inline редактирования колонок
    private async Task HandleColumnTitleKeyPress(KeyboardEventArgs e, KanbanColumn column)
    {
        if (e.Key == "Enter")
        {
            await SaveColumnChanges(column);
        }
        else if (e.Key == "Escape")
        {
            CancelEditingColumn(column.Id);
        }
    }

    private async Task SelectColumnInputText(FocusEventArgs e)
    {
        // Выделяем весь текст при фокусе на input колонки
        await JSRuntime.InvokeVoidAsync("eval", "event.target.select()");
    }

    // Метод для показа анимации успеха
    private async Task ShowSuccessAnimation(string taskId)
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("eval", $@"
                const taskElement = document.getElementById('task-{taskId}');
                if (taskElement) {{
                    taskElement.classList.add('save-success');
                    setTimeout(() => {{
                        taskElement.classList.remove('save-success');
                    }}, 2000);
                }}
            ");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Ошибка показа анимации успеха: {ex.Message}");
        }
    }

    // Метод для показа анимации успеха колонки
    private async Task ShowColumnSuccessAnimation(string columnId)
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("eval", $@"
                const columnElement = document.getElementById('column-{columnId}');
                if (columnElement) {{
                    columnElement.classList.add('save-success');
                    setTimeout(() => {{
                        columnElement.classList.remove('save-success');
                    }}, 2000);
                }}
            ");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Ошибка показа анимации успеха колонки: {ex.Message}");
        }
    }

    // Методы для стилизации
    private string GetTagClasses(string tag)
    {
        return tag.ToLower() switch
        {
            "frontend" => "bg-blue-100 text-blue-800",
            "backend" => "bg-green-100 text-green-800",
            "bug" => "bg-red-100 text-red-800",
            "feature" => "bg-purple-100 text-purple-800",
            "urgent" => "bg-orange-100 text-orange-800",
            "design" => "bg-pink-100 text-pink-800",
            "testing" => "bg-yellow-100 text-yellow-800",
            _ => "bg-gray-100 text-gray-800"
        };
    }

    private string GetDueDateClasses(DateTime dueDate)
    {
        var daysUntilDue = (dueDate.Date - DateTime.UtcNow.Date).Days;

        if (daysUntilDue < 0)
            return "text-red-600 font-medium"; // Просрочено
        else if (daysUntilDue == 0)
            return "text-orange-600 font-medium"; // Сегодня
        else if (daysUntilDue == 1)
            return "text-yellow-600 font-medium"; // Завтра
        else
            return "text-gray-500"; // Обычная дата
    }

    private string GetAssigneeColor(string assignee)
    {
        // Простая функция для генерации цвета на основе имени
        var hash = assignee.GetHashCode();
        var colors = new[]
        {
"bg-blue-500", "bg-green-500", "bg-purple-500", "bg-pink-500",
"bg-indigo-500", "bg-red-500", "bg-yellow-500", "bg-teal-500"
};

        return colors[Math.Abs(hash) % colors.Length];
    }

    public async ValueTask DisposeAsync()
    {
        if (dotNetRef != null)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("kanbanDragDrop.cleanup");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"❌ BLAZOR: Ошибка при очистке: {ex.Message}");
            }
            dotNetRef.Dispose();
        }
        await Task.CompletedTask;
    }

    // Публичный метод для переинициализации drag-and-drop (для вызова извне)
    public async Task RefreshDragAndDrop()
    {
        if (jsInteropDone && !isTaskMoving)
        {
            Console.WriteLine("🔄 BLAZOR: Внешний вызов переинициализации drag-and-drop...");
            await ReinitializeDragAndDrop();
        }
        else if (isTaskMoving)
        {
            Console.WriteLine("⏸️ BLAZOR: Внешняя переинициализация пропущена - задача в процессе перемещения");
        }
    }
}